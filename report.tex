\documentclass[oneside,12pt,english]{article}
\usepackage{amsmath,amsfonts,stmaryrd,amssymb, enumerate, amsthm, mathtools}
\newtheorem{theorem}{Theorem}
\usepackage{enumerate}
\usepackage{multirow}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}
\theoremstyle{definition}
\usepackage{float}
\newtheorem{definition}{Definition}
\usepackage{algorithm}
\usepackage{babel}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{hyperref}
\usepackage{geometry, parskip}
\geometry{
	paper=a4paper,
	top=2.5cm,
	left=2.5cm,
	right=2.5cm,
}
\usepackage{booktabs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{XCharter, enumitem}
\usepackage[most]{tcolorbox}

% Additional packages for professional appearance
\usepackage{titling}
\usepackage{fancyhdr}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{graphicx}

% Define colors
\definecolor{darkgray}{RGB}{64,64,64}

% Configure hyperref colors
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    urlcolor=black,
    pdfborderstyle={/S/U/W 1}
}


% Custom author formatting
\preauthor{%
  \begin{center}
  \vspace{3em}
    {\Large\textbf{Project Team}}\\[2em]
    \begin{tabular}{c}
      {\large Jintian Wang (z5536837)} \\[0.5em]
      {\large Dennis Shu (z5522609)} \\[0.5em]
      {\large Evan Lin (z5589313)} \\[1em]
      \large\textbf{Mentor:} {\large Ayda Valinezhad Orang}
    \end{tabular}
  \end{center}
}
\postauthor{}

% Custom date formatting
\predate{%
  \begin{center}
  \vfill
  {\normalsize School of Computer Science and Engineering}\\
  {\normalsize University of New South Wales}\\
  {\normalsize Sydney, Australia}\\[0.5em]
  {\normalsize November 2024}
  \end{center}
}
\postdate{}


% Configure fancy headers for subsequent pages
\pagestyle{fancy}
\fancyhf{}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

% Customize section headers
\usepackage{titlesec}
\titleformat{\section}
  {\Large\bfseries}
  {\thesection}
  {1em}
  {}
  [\vspace{-0.5em}\rule{\textwidth}{1pt}]

\title{Greedy Scheduling with Dynamic Priority Elevations and Deadlines\\[0.5em]
{\large Group 5}}
\author{}
\date{}

\begin{document}

% Create the title page
\begin{titlepage}
\maketitle
\thispagestyle{empty}
\end{titlepage}

% Reset page numbering and apply fancy headers
\setcounter{page}{1}
\thispagestyle{fancy}

% Table of contents with custom formatting
\renewcommand{\contentsname}{\Large Table of Contents}
\tableofcontents
\newpage

\section{Introduction}
\label{sec:introduction}

This project investigates parallel machine scheduling with priority classes and deadlines, comparing three baseline algorithms (SPT, EDF, Priority-First) against Dynamic Priority Elevation (DPE), a novel threshold-based mechanism. Through comprehensive evaluation across 14 scenarios and 84 experimental runs, we find that DPE provides no measurable advantage over simple baseline algorithms. An important discovery during validation revealed a critical EDF implementation bug; after correction, EDF demonstrated superior performance in deadline-critical scenarios (16.7\% better makespan) while SPT excelled for batch processing (7.1\% advantage). These results validate context-specific algorithm selection over complex dynamic mechanisms.

\subsection{Contributions}

This work makes the following contributions to parallel machine scheduling research:

\begin{enumerate}
    \item \textbf{Comprehensive experimental evaluation} of priority-based scheduling algorithms across 14 diverse scenarios, demonstrating that resource provisioning dominates algorithmic sophistication in 79\% of tested cases.

    \item \textbf{Negative result documentation} showing DPE provides no advantage over baselines, guiding practitioners toward proven strategies and identifying conditions where dynamic elevation mechanisms fail to provide value.

    \item \textbf{Critical implementation validation} discovering and fixing an EDF bug that improved success rates by up to 25 percentage points (from 75\% to 100\% in Extreme 3), demonstrating the importance of rigorous testing in experimental algorithm research.

    \item \textbf{Theoretical analysis} including SPT optimality proof via exchange argument and time complexity analysis ($O(n \log n)$ for all algorithms).

    \item \textbf{Practical recommendations} for algorithm selection based on empirical evidence: SPT for batch processing, EDF for deadline-critical systems, adequate resource provisioning over complex mechanisms.
\end{enumerate}

\section{Background and Related Work}
\label{sec:background}

\subsection{Scheduling Theory Foundations}

Parallel machine scheduling is a classical problem in combinatorial optimization with applications in manufacturing, cloud computing, and real-time systems. Graham's seminal work \cite{graham1966bounds} established fundamental bounds for multiprocessor scheduling, proving that any list scheduling algorithm achieves a makespan $\omega \leq (2 - \frac{1}{m}) \times \omega_0$, where $\omega_0$ is the optimal makespan and $m$ is the number of identical machines. This theoretical guarantee motivates the study of greedy scheduling strategies that can approach or achieve optimal solutions in practice.

\subsection{Deadline-Aware Scheduling}

Earliest Deadline First (EDF) scheduling, introduced by Liu and Layland \cite{LIULAYLAND1973}, achieves optimal processor utilization on single-processor systems by dynamically assigning priorities based on task deadlines. Their foundational result demonstrates that EDF can schedule any feasible task set for which total utilization is at most 100\%. While originally developed for real-time systems, EDF's deadline-aware prioritization extends naturally to parallel machine environments where multiple deadlines must be satisfied.

Lee and Pinedo \cite{LEE1997464} developed multi-phase approaches combining different greedy strategies with local search optimization for parallel machine scheduling with sequence-dependent setup times. Their methodology—applying different heuristics followed by refinement—directly parallels our approach of comparing baseline algorithms before introducing dynamic priority mechanisms.

\subsection{Priority-Based Scheduling}

Modern scheduling systems must balance competing objectives: urgent tasks require immediate attention, while routine tasks should not starve indefinitely. Kahraman et al. \cite{KAHRAMAN20101293} explored multiprocessor task scheduling using parallel greedy algorithms in multistage hybrid flow-shops, demonstrating that greedy strategies can effectively handle priority constraints when combined with appropriate tie-breaking rules.

\subsection{Applications}

The scheduling problem addressed in this work has direct practical applications:

\textbf{Cloud Computing}: Zhang et al. \cite{ZHANG202031} apply priority-based deadline scheduling to scientific workflows in cloud environments, where premium customers (high priority) and standard customers (low priority) must both meet their deadlines while maximizing resource utilization. This two-tier priority structure motivates our problem formulation.

\textbf{Emergency Department Management}: Alves de Queiroz et al. \cite{ALVESDEQUEIROZ2023100} address dynamic patient scheduling with priority classes, where urgent cases and non-urgent cases must be balanced to ensure timely medical services for critical patients while efficiently managing routine cases. This real-world application demonstrates that priority-aware scheduling addresses genuine societal needs.

\subsection{Motivation for Dynamic Priority Elevation}

Traditional static priority scheduling can lead to low-priority task starvation: when high-priority work continually arrives, lower-priority tasks may be postponed indefinitely. While this guarantees high-priority performance, it creates unfairness and unpredictable delays for routine work. Our Dynamic Priority Elevation mechanism aims to address this limitation by temporarily promoting low-priority tasks based on deadline pressure, maintaining high-priority guarantees while preventing indefinite postponement.

\section{Problem Statement}
\label{sec:problem}

We formalize the parallel machine scheduling problem with priority classes and deadline constraints.

\subsection{Definitions}

\begin{definition}[Problem Instance]
    An instance consists of:
    \begin{itemize}
        \item A set of $n$ indivisible tasks $\mathcal{T} = \{T_1, T_2, \ldots, T_n\}$
        \item A set of $m$ identical parallel machines $\mathcal{M} = \{M_1, M_2, \ldots, M_m\}$
        \item Each task $T_i$ has:
        \begin{itemize}
            \item Processing time $p_i > 0$
            \item Priority class $c \in \{h, l\}$ where $h$ is high priority and $l$ is low priority
            \item Arrival time $a_i \geq 0$
        \end{itemize}
        \item Machine properties:
        \begin{itemize}
            \item A machine can only process 1 task at a time
            \item Each task is assigned to exactly one machine (indivisible)
            \item Once a machine begins processing task $T_i$, it works without interruption until completion (non-preemptive)
        \end{itemize}
        \item Deadline constraints:
        \begin{itemize}
            \item High priority tasks have deadline $D_h > 0$
            \item Low priority tasks have deadline $D_l > 0$
            \item $D_h < D_l$ (high priority tasks have earlier deadlines)
        \end{itemize}
    \end{itemize}
\end{definition}

\begin{definition}[Completion Time]
For a task $T_i$ with arrival time $a_i$ and start time $s_i \geq a_i$, the completion time is:
\[
C_i = s_i + p_i
\]
\end{definition}

\begin{definition}[Feasible Schedule]
    A schedule is \emph{feasible} if:
    \begin{itemize}
        \item For every high-priority task $T_i$: $C_i \leq D_h$
        \item For every low-priority task $T_j$: $C_j \leq D_l$
    \end{itemize}
\end{definition}

\begin{definition}[Makespan]
The \emph{makespan} of a schedule is the completion time of the last task:
\[
C_{\max} = \max_{i \in [n]} C_i
\]
\end{definition}

\subsection{Objective}

Design a polynomial-time algorithm to find a feasible schedule that minimizes the makespan $C_{\max}$ while preventing starvation of low-priority tasks.

\section{Methodology}
\label{sec:methodology}

We implemented and evaluated four scheduling algorithms: three established baselines (SPT, EDF, Priority-First) and our novel Dynamic Priority Elevation mechanism.

\subsection{Baseline Algorithms}

\subsubsection{Shortest Processing Time First (SPT)}

SPT minimizes average completion time by scheduling tasks in increasing order of processing time. For parallel machines, we assign each task to the machine that becomes available earliest.

\textbf{Algorithm}: Sort all tasks by processing time $p_i$ in ascending order. For each task in sorted order, assign to the machine with minimum availability time.

\textbf{Rationale}: SPT optimizes for overall system throughput by completing short tasks quickly, reducing average response time.

\subsubsection{Earliest Deadline First (EDF)}

EDF prioritizes tasks by deadline, scheduling the most urgent task first. This is optimal for single-processor deadline-constrained scheduling \cite{LIULAYLAND1973}.

\textbf{Algorithm}: Sort all tasks by deadline in ascending order. For each task in sorted order, assign to the machine with minimum availability time.

\textbf{Rationale}: Deadline-aware scheduling maximizes the probability of meeting time constraints by addressing urgent work first.

\subsubsection{Priority-First Scheduling}

Priority-First enforces strict priority ordering: all high-priority tasks are scheduled before any low-priority task, regardless of other attributes.

\textbf{Algorithm}: Sort tasks with high-priority tasks first, then low-priority tasks. Within each priority class, use SPT as a tie-breaker. For each task in sorted order, assign to the machine with minimum availability time.

\textbf{Rationale}: This guarantees high-priority task performance but risks low-priority task starvation.

\subsection{Dynamic Priority Elevation (DPE)}

DPE dynamically promotes low-priority tasks when their deadline pressure exceeds a threshold $\alpha$.

\textbf{Deadline Pressure}:
For a low-priority task $T_i$ at current time $t$, deadline pressure is:
\[
\text{deadline\_pressure}(T_i, t) = \frac{t - a_i}{D_l - a_i}
\]

This measures the fraction of available deadline window consumed. When $\text{deadline\_pressure}(T_i, t) > \alpha$, task $T_i$ is temporarily elevated to high priority.

\textbf{Algorithm}: At each scheduling decision point:
\begin{enumerate}
    \item Calculate deadline pressure for all waiting low-priority tasks
    \item Elevate tasks with pressure $> \alpha$ to high priority
    \item Schedule using priority-aware EDF (considering both original and elevated priorities)
    \item Tasks revert to original priority after scheduling
\end{enumerate}

\textbf{Parameters}: We tested $\alpha \in \{0.5, 0.7, 0.9\}$, where $\alpha = 0.7$ means elevation triggers when a task has consumed 70\% of its deadline window without starting.

\textbf{Rationale}: DPE aims to prevent starvation while maintaining high-priority guarantees by elevating only tasks approaching deadline expiration.

\subsection{Implementation}

All algorithms were implemented in Python using a discrete-event simulator. The simulator maintains:
\begin{itemize}
    \item Event queue (priority queue of arrival and completion events)
    \item Ready queue (tasks waiting for machine assignment)
    \item Machine availability tracker (earliest available time for each machine)
\end{itemize}


\section{Theoretical Analysis}
\label{sec:theory}

\subsection{SPT Optimality for Single Machine}

\begin{theorem}
For a single machine with $n$ tasks and no deadlines or priorities, SPT minimizes the sum of completion times.
\end{theorem}

\begin{proof}
We prove by exchange argument. Suppose $\sigma$ is an optimal schedule that is not SPT. Then there exist adjacent tasks $T_i, T_j$ in $\sigma$ where $T_i$ is scheduled before $T_j$ but $p_i > p_j$.

Let $\sigma'$ be the schedule obtained by swapping $T_i$ and $T_j$. Let $t$ be the start time of $T_i$ in $\sigma$.

\textbf{In schedule $\sigma$:}
\begin{itemize}
    \item $T_i$ completes at $t + p_i$
    \item $T_j$ completes at $t + p_i + p_j$
    \item Contribution to sum: $(t + p_i) + (t + p_i + p_j) = 2t + 2p_i + p_j$
\end{itemize}

\textbf{In schedule $\sigma'$ (after swap):}
\begin{itemize}
    \item $T_j$ completes at $t + p_j$
    \item $T_i$ completes at $t + p_j + p_i$
    \item Contribution to sum: $(t + p_j) + (t + p_j + p_i) = 2t + p_i + 2p_j$
\end{itemize}

\textbf{Difference:}
\[
(2t + 2p_i + p_j) - (2t + p_i + 2p_j) = p_i - p_j > 0
\]

Thus $\sigma'$ has strictly smaller total completion time than $\sigma$, contradicting optimality of $\sigma$. By repeatedly applying this swap to all out-of-order pairs, we obtain an SPT schedule with no greater total completion time than any other schedule.
\end{proof}

\subsection{Time Complexity Analysis}

\begin{theorem}
All implemented algorithms (SPT, EDF, Priority-First, DPE) have time complexity $O(n \log n)$ where $n$ is the number of tasks.
\end{theorem}

\begin{proof}
For each algorithm:

\textbf{SPT, EDF, Priority-First:}
\begin{itemize}
    \item Sorting phase: $O(n \log n)$ using comparison-based sort
    \item Assignment phase: $O(n)$ iterations, each finding minimum availability among $m$ machines in $O(m)$ time
    \item Since $m \ll n$ typically (constant number of machines), assignment is $O(n)$
    \item \textbf{Total}: $O(n \log n) + O(n \cdot m) = O(n \log n)$
\end{itemize}

\textbf{DPE:}
\begin{itemize}
    \item Event queue operations: $O(\log n)$ per insertion/extraction, $O(n \log n)$ total for $n$ tasks
    \item Deadline pressure calculation per scheduling decision: $O(k)$ where $k$ is number of waiting tasks
    \item Ready queue sorting at each decision point: $O(k \log k)$ where $k \leq n$
    \item In typical case with distributed arrivals: $O(n)$ scheduling decisions with average $k \ll n$, giving $O(n \log n)$ total
    \item \textbf{Typical case}: $O(n \log n)$
\end{itemize}
\end{proof}

\section{Experimental Setup}
\label{sec:experiments}

\subsection{Test Scenarios}

We designed 14 test scenarios across three difficulty categories to systematically evaluate algorithm performance under varying conditions.

\begin{table}[H]
\centering
\caption{Test Scenario Overview (M=Machines, H=High Priority, L=Low Priority)}
\label{tab:test_overview}
\begin{tabular}{lc}
\toprule
Scenario & Configuration \\
\midrule
\multicolumn{2}{c}{\textit{Basic Scenarios}} \\
\midrule
Light Load & 5 tasks (3H+2L), 2M \\
Heavy Load & 7 tasks (4H+3L), 3M \\
Starvation Test & 7 tasks (5H+2L), 2M \\
Batch Arrival & 6 tasks (3H+3L), 2M \\
\midrule
\multicolumn{2}{c}{\textit{Challenging Scenarios}} \\
\midrule
Challenge 1: SPT vs EDF & 4H, 2M \\
Challenge 2: Starvation & 4H+2L, 2M \\
Challenge 3: Impossible & 4H, 2M \\
Challenge 4: Alpha Matters & 3H+2L, 2M \\
Challenge 5: Priority Inversion & 2H+1L, 1M \\
\midrule
\multicolumn{2}{c}{\textit{Extreme Scenarios}} \\
\midrule
Extreme 1: Starvation Guaranteed & 6H+1L, 1M \\
Extreme 2: Alpha Critical & 7H+1L, 1M \\
Extreme 3: SPT Fails & 4H, 2M \\
Extreme 4: Multiple Starvation & 6H+3L, 2M \\
Extreme 5: Priority-First Impossible & 2H+1L, 1M \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Test Coverage}: 14 scenarios × 6 algorithms (SPT, EDF, Priority-First, DPE with $\alpha \in \{0.5, 0.7, 0.9\}$) = 84 experimental runs.

\subsection{Metrics Collected}

For each experimental run, we measured:
\begin{itemize}
    \item \textbf{Makespan}: Total completion time (lower is better)
    \item \textbf{Deadline Success Rate}: Percentage of tasks meeting their deadlines (higher is better)
    \item \textbf{High/Low Priority Success Rates}: Separate metrics for each priority class
    \item \textbf{Average Response Time}: Mean time from arrival to completion
\end{itemize}

\section{Results}
\label{sec:results}

\subsection{Critical EDF Bug Fix}

During validation, we discovered that EDF produced identical schedules to SPT despite fundamentally different theoretical foundations.

\textbf{Root Cause}: Processing arrivals one-by-one caused premature scheduling. When tasks arrived simultaneously, the scheduler couldn't compare all deadlines, breaking EDF's optimality.

\textbf{Fix}: Batch process all events at each timestamp—first add all arrivals to the ready queue, then schedule once. This ensures EDF sees the complete set of available tasks.

\textbf{Impact}: After the fix, EDF showed measurably superior performance in deadline-critical scenarios:

\begin{table}[H]
\centering
\caption{EDF Performance Improvement After Bug Fix}
\label{tab:edf_fix_impact}
\begin{tabular}{lcccc}
\toprule
& \multicolumn{2}{c}{\textbf{Success Rate (\%)}} & \multicolumn{2}{c}{\textbf{Makespan}} \\
\cmidrule(lr){2-3} \cmidrule(lr){4-5}
\textbf{Scenario} & Before & After & Before & After \\
\midrule
Extreme 1 & 85.7 & \textbf{100.0} & 17 & 17 \\
Extreme 3 & 75.0 & \textbf{100.0} & 12 & \textbf{10} \\
\bottomrule
\end{tabular}
\end{table}

The bug fix validates EDF as an effective deadline-aware baseline, making comparative analysis scientifically meaningful. All results reported below use the corrected implementation.

\subsection{Comprehensive Performance Comparison}

After fixing EDF, we re-ran all 84 experiments. Figure \ref{fig:makespan_comparison} shows makespan comparison across all scenarios and algorithms.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{simulator/visualizations/makespan_comparison_detailed.png}
\caption{Makespan comparison across all 14 scenarios and 6 algorithm variants. DPE variants (red shades) consistently match or exceed baseline makespans, never achieving superior performance.}
\label{fig:makespan_comparison}
\end{figure}

\begin{table}[H]
\centering
\caption{Overall Algorithm Performance Across All 14 Scenarios}
\label{tab:overall_performance}
\begin{tabular}{lcccc}
\toprule
\textbf{Algorithm} & \textbf{Scenarios Won} & \textbf{Avg Makespan} & \textbf{Avg Success (\%)} \\
\midrule
SPT & 1/14 (Batch Arrival) & 12.2 & 83.8 \\
EDF & 1/14 (Extreme 3) & \textbf{12.1} & \textbf{91.7} \\
Priority-First & 0/14 & 12.1 & 87.4 \\
DPE ($\alpha=0.5$) & 0/14 & 12.1 & 89.3 \\
DPE ($\alpha=0.7$) & 0/14 & 12.1 & 88.3 \\
DPE ($\alpha=0.9$) & 0/14 & 12.1 & 87.4 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Key Finding}: EDF emerges as the best overall performer after bug fix, achieving lowest average makespan and highest success rate. DPE never outperformed any baseline in any scenario.

\subsection{Scenarios Where Algorithms Differ}

Two scenarios revealed meaningful performance differences among baseline algorithms, demonstrating context-specific advantages.

\begin{table}[H]
\centering
\caption{Scenarios Demonstrating Algorithm Differentiation}
\label{tab:differences}
\begin{tabular}{llccc}
\toprule
Scenario & Algorithm & Success (\%) & Makespan & Performance \\
\midrule
\textbf{Batch Arrival} & SPT & 100.0 & \textbf{13} & \textbf{7.1\% better} \\
 & EDF & 100.0 & 14 & baseline \\
 & Priority-First & 100.0 & 14 & baseline \\
 & DPE (all $\alpha$) & 100.0 & 14 & baseline \\
\midrule
\textbf{Extreme 3} & SPT & 75.0 & 12 & baseline \\
 & EDF & \textbf{100.0} & \textbf{10} & \textbf{16.7\% better} \\
 & Priority-First & 100.0 & 10 & tied \\
 & DPE (all $\alpha$) & 100.0 & 10 & tied \\
\bottomrule
\end{tabular}
\end{table}

Figures \ref{fig:batch_spt}--\ref{fig:ext3_edf} show Gantt chart visualizations of these scenarios, illustrating how different scheduling strategies allocate tasks across machines and time.

\begin{figure}[H]
\centering
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{simulator/visualizations/Batch_Arrival_SPT_gantt.png}
    \caption{Batch Arrival: SPT achieves makespan=13 (7.1\% better) by scheduling shortest tasks first, reducing idle time}
    \label{fig:batch_spt}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{simulator/visualizations/Batch_Arrival_EDF_gantt.png}
    \caption{Batch Arrival: EDF achieves makespan=14, demonstrating SPT's advantage for simultaneous arrivals}
    \label{fig:batch_edf}
\end{minipage}
\end{figure}

\begin{figure}[H]
\centering
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{simulator/visualizations/Extreme_3_SPT_gantt.png}
    \caption{Extreme 3 (SPT Fails): SPT achieves only 75\% success rate and makespan=12}
    \label{fig:ext3_spt}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{simulator/visualizations/Extreme_3_EDF_gantt.png}
    \caption{Extreme 3 (SPT Fails): EDF achieves 100\% success and makespan=10 (16.7\% better) by prioritizing deadline-critical tasks}
    \label{fig:ext3_edf}
\end{minipage}
\end{figure}

\subsection{Baseline Equivalence in Well-Provisioned Scenarios}

Eleven scenarios (79\%) showed identical performance across all algorithms, achieving either 100\% success or identical partial failure rates.

\begin{table}[H]
\centering
\caption{Scenarios with Identical Algorithm Performance (11/14 total)}
\label{tab:baseline}
\begin{tabular}{lccc}
\toprule
Scenario & Tasks & Machines & Makespan \\
\midrule
Light Load & 5 & 2 & 12 \\
Heavy Load & 7 & 3 & 13 \\
Starvation Test & 7 & 2 & 8 \\
Challenge 2 & 6 & 2 & 7 \\
Extreme 1 & 7 & 1 & 17 \\
Extreme 2 & 8 & 1 & 21 \\
Extreme 4 & 9 & 2 & 12 \\
Extreme 5 & 3 & 1 & 10 \\
\bottomrule
\end{tabular}
\end{table}

This demonstrates that when machine capacity sufficiently exceeds task demands, scheduling strategy becomes inconsequential—all algorithms achieve optimal or near-optimal results.

\subsection{DPE Performance Analysis}

Across all 14 comprehensive scenarios, DPE never outperformed baseline algorithms.

\begin{table}[H]
\centering
\caption{DPE vs Best Baseline: Comprehensive Comparison}
\label{tab:dpe_performance}
\begin{tabular}{lcc}
\toprule
Scenario Category & Count & DPE Performance \\
\midrule
Identical to all algorithms & 11/14 & No differentiation \\
Inferior to SPT (Batch Arrival) & 1/14 & 7.1\% worse makespan \\
Inferior to EDF (Extreme 3) & 1/14 & 16.7\% worse makespan \\
Matched best algorithm (Challenge 2) & 1/14 & Equal performance \\
\midrule
\textbf{Total scenarios where DPE won} & \textbf{0/14} & \textbf{Never superior} \\
\bottomrule
\end{tabular}
\end{table}

The $\alpha$ parameter (tested at 0.5, 0.7, 0.9) made no observable difference across any scenario, suggesting either test scenarios lacked sufficient deadline pressure to trigger differential elevation behavior, or the elevation mechanism does not function as designed.

\section{Discussion}
\label{sec:discussion}

\subsection{Why DPE Provided No Advantage}

Our comprehensive evaluation reveals four primary factors explaining DPE's lack of advantage:

\subsubsection{Resource Abundance (Primary Factor)}

In 11/14 scenarios (79\%), machine capacity sufficiently exceeded task demands. When well-provisioned, scheduling strategy becomes irrelevant—all algorithms achieve optimal or near-optimal results. This demonstrates a fundamental insight: \textbf{resource provisioning dominates algorithmic sophistication}. No amount of clever scheduling can overcome resource constraints, and adequate resources make sophisticated algorithms unnecessary.

\subsubsection{Test Scenario Limitations}

Our scenarios may lack conditions creating sufficient deadline pressure for DPE elevation to provide value. Characteristics that might enable DPE advantages include:
\begin{itemize}
    \item Continuous task arrivals (not batch arrivals at time 0)
    \item Tighter deadlines relative to processing times (higher utilization)
    \item Higher machine utilization (90\%+ capacity)
    \item More low-priority tasks approaching starvation conditions
    \item Dynamic arrival patterns with bursts of high-priority work
\end{itemize}

Future work should design scenarios specifically targeting these conditions to fairly evaluate DPE's potential.

\subsubsection{Non-Preemptive Scheduling Constraints}

Challenge 5 demonstrated complete high-priority failure (0\% success) despite 100\% low-priority success, exposing fundamental limits of non-preemptive scheduling. When a low-priority task occupies a machine, no strategy can help high-priority tasks that arrive subsequently. Non-preemptive constraints create mathematical barriers no scheduling algorithm can overcome. DPE cannot elevate tasks that have not yet arrived, and cannot preempt running tasks.

\subsubsection{Alpha Parameter Insensitivity}

Testing $\alpha \in \{0.5, 0.7, 0.9\}$ produced no observable differences across any scenario. This suggests:
\begin{itemize}
    \item Test scenarios don't create deadline pressure conditions where elevation triggers
    \item Elevation mechanism implementation may require validation
    \item DPE concept may need fundamental refinement (alternative elevation criteria)
\end{itemize}

\subsection{Value of Negative Results}

This negative result constitutes valid research contribution. Negative results are valuable when they meet four criteria:

\begin{enumerate}
    \item \textbf{Hypothesis was reasonable}: DPE concept is theoretically sound—preventing starvation while maintaining priority guarantees is a worthy goal.

    \item \textbf{Methodology was rigorous}: 14 scenarios across three difficulty categories, 84 total runs, systematic evaluation with consistent metrics.

    \item \textbf{Conclusions are clear}: Simple, context-appropriate algorithms outperform complex dynamic mechanisms in tested configurations.

    \item \textbf{Practical implications}: Results guide practitioners toward proven strategies and adequate resource provisioning rather than algorithmic complexity.
\end{enumerate}

Our findings provide actionable insights: provision resources first, choose context-specific algorithms, avoid premature optimization, and prioritize implementation quality.

\subsection{Practical Recommendations}

Based on comprehensive evaluation across 14 scenarios and 84 experimental runs:

\begin{itemize}
    \item \textbf{Provision resources adequately}: In 79\% of scenarios, algorithm choice was irrelevant when capacity exceeded demands. Capacity matters more than algorithmic sophistication.

    \item \textbf{Choose context-specific algorithms}:
    \begin{itemize}
        \item \textbf{SPT} for batch processing scenarios where tasks arrive simultaneously (7.1\% advantage)
        \item \textbf{EDF} for deadline-critical systems where meeting time constraints is paramount (16.7\% advantage, best overall performance)
        \item \textbf{Priority-First} when strict priority ordering is mandatory for correctness
    \end{itemize}

    \item \textbf{Avoid premature optimization}: Complex dynamic mechanisms like DPE add implementation complexity and testing burden without demonstrated benefit in typical scenarios.

    \item \textbf{Prioritize implementation quality}: The EDF bug invalidated initial results, demonstrating that correct implementation of simple algorithms outperforms buggy implementation of sophisticated approaches. Rigorous testing is essential.

    \item \textbf{Monitor system utilization}: When utilization approaches 90\%+, consider capacity expansion before algorithmic refinement.
\end{itemize}

\section{Conclusions and Future Work}
\label{sec:conclusions}

\subsection{Summary of Contributions}

This experimental study investigated Dynamic Priority Elevation for parallel machine scheduling with priority classes and deadlines. Through comprehensive evaluation across 14 scenarios and 84 runs, we make the following contributions:

\begin{enumerate}
    \item \textbf{Negative result documentation}: DPE provided no advantage across all tested scenarios, guiding practitioners toward proven baseline strategies.

    \item \textbf{Algorithm performance characterization}: SPT excels for batch processing (7.1\% better makespan), EDF excels for deadline-critical systems (16.7\% better makespan, best overall performance).

    \item \textbf{Resource dominance finding}: In 79\% of scenarios, algorithm choice was irrelevant when systems were well-provisioned, demonstrating that capacity planning dominates algorithmic sophistication.

    \item \textbf{Theoretical analysis}: SPT optimality proof via exchange argument and $O(n \log n)$ time complexity analysis for all algorithms.

    \item \textbf{Implementation validation}: Discovery and correction of critical EDF bug that improved deadline success rates by up to 25\% (from 75\% to 100\% in Extreme 3), emphasizing the importance of rigorous testing in algorithm research.
\end{enumerate}

\subsection{Lessons Learned}

\textbf{Evidence-based algorithm selection outperforms complexity for its own sake}. Our research demonstrates that simple, proven, context-appropriate strategies (SPT for batch, EDF for deadlines) excel in their target contexts. When systems are well-provisioned, algorithm choice is irrelevant. When resource-constrained, correct implementation of simple baselines suffices for practical parallel machine scheduling.

The critical EDF bug discovery highlights a meta-lesson: algorithmic sophistication means nothing without implementation quality. Rigorous testing, systematic validation, and honest reporting of both positive and negative results advance scientific understanding more than premature claims of algorithmic superiority.

\subsection{Limitations}

\begin{enumerate}
    \item \textbf{Scenario coverage}: Test scenarios may not create sufficient deadline pressure to stress-test DPE advantages. Higher utilization scenarios (90\%+) and continuous arrival patterns remain unexplored.

    \item \textbf{Implementation uncertainty}: Alpha parameter insensitivity suggests potential issues in DPE implementation or insufficient triggering conditions in test workloads.

    \item \textbf{Two priority classes only}: Extension to $k$ priority classes ($k > 2$) may reveal different behaviors where multi-level elevation becomes valuable.

    \item \textbf{Static workloads}: Most scenarios use batch arrivals at time 0. Dynamic arrival patterns with varying arrival rates remain largely untested.

    \item \textbf{Non-preemptive constraint}: All algorithms assume non-preemptive scheduling. Preemptive variants may enable DPE advantages by allowing interruption of low-priority work.
\end{enumerate}

\subsection{Future Research Directions}

\textbf{Algorithmic Refinements}:
\begin{itemize}
    \item Alternative elevation criteria (absolute waiting time, relative slack time, predicted starvation probability)
    \item Hybrid approaches combining DPE with baseline strategies (e.g., DPE-enhanced EDF)
    \item Adaptive threshold learning from workload characteristics using machine learning
    \item Preemptive scheduling variants to test if preemption enables DPE advantages
\end{itemize}

\textbf{Extended Evaluation}:
\begin{itemize}
    \item DPE-focused scenarios with higher utilization (90\%+ machine capacity)
    \item Multiple priority classes ($k > 2$) with hierarchical elevation mechanisms
    \item Online algorithms for unknown future task arrivals
    \item Real workload traces from cloud computing and manufacturing systems
    \item Continuous arrival processes (Poisson arrivals, time-varying rates)
\end{itemize}

\textbf{Theoretical Extensions}:
\begin{itemize}
    \item Approximation guarantees for DPE (competitive ratio analysis)
    \item Competitive analysis against optimal offline solutions
    \item Hardness results for optimal scheduling with dynamic priority elevation
    \item Characterization of conditions under which dynamic priority provides provable advantage
    \item Lower bounds on achievable performance for priority-constrained scheduling
\end{itemize}

\subsection{Closing Remarks}

Our investigation of Dynamic Priority Elevation demonstrates that negative results provide valuable scientific contributions when methodology is rigorous and conclusions are actionable. The evidence shows that DPE, as currently designed, offers no advantage over simple baseline algorithms across all tested scenarios. This finding connects directly to the background literature: Graham's bounds \cite{graham1966bounds} establish theoretical performance guarantees for list scheduling, Liu and Layland's EDF optimality \cite{LIULAYLAND1973} provides deadline-aware foundations, and Lee and Pinedo's multi-phase approach \cite{LEE1997464} validates comparative evaluation of greedy strategies.

Our experimental work extends this foundation by demonstrating that in parallel machine environments with priority constraints, simple context-appropriate algorithms (SPT for batch processing, EDF for deadline-critical systems) outperform complex dynamic mechanisms. The critical EDF bug discovery reinforces the meta-lesson that implementation quality dominates algorithmic sophistication—a poorly implemented sophisticated algorithm cannot compete with correctly implemented simple baselines.

For practitioners facing parallel machine scheduling challenges, our results provide clear guidance: (1) provision resources adequately first, (2) select proven baseline algorithms matched to workload characteristics, and (3) invest in rigorous testing and validation rather than algorithmic complexity. For researchers, our work identifies conditions where dynamic priority elevation fails and motivates investigation of scenarios where such mechanisms might provide genuine value—particularly in high-utilization environments with continuous arrival patterns and tighter deadline constraints.

\section*{Acknowledgments}

We thank our mentor Ayda Valinezhad Orang for guidance throughout this project.

% Bibliography
\newpage
\renewcommand{\refname}{\Large References}
\bibliographystyle{plain}
\bibliography{references}

\end{document}
